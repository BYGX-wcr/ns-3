Index: src/internet/doc/ipv4.rst
===================================================================
--- a/src/internet/doc/ipv4.rst
+++ b/src/internet/doc/ipv4.rst
@@ -115,3 +115,26 @@
 - If a packet is being forwarded, and the TTL is exceeded (see
   ns3::Ipv4L3Protocol::DoForward), the packet is dropped and the "Drop" trace
   event is fired.
+
+Explicit Congestion Notification (ECN) bits
+*******************************************
+
+- In IPv4, ECN bits are the last 2 bits in TOS field and occupy 14th and 15th
+  bits in the header.
+
+- The IPv4 header class defines an EcnType enum with all four ECN codepoints    
+  (ECN_NotECT, ECN_ECT1, ECN_ECT0, ECN_CE) mentioned
+  in RFC 3168, and also a setter and getter method to handle ECN values in 
+  the TOS field.
+
+Ipv4QueueDiscItem
+*****************
+
+The traffic control sublayer in |ns3| handles objects of class
+``QueueDiscItem`` which are used to hold an ns3::Packet and a ns3::Header.
+This is done to facilitate the marking of packets for Explicit
+Congestion Notification.  The ``Mark ()`` method is implemented in 
+Ipv4QueueDiscItem. It is a boolean method and returns true if marking 
+the packet is successful; i.e., it successfully sets the CE bit in 
+IPv4 header.  ``Mark ()`` will return false, however, if the IPv4
+header indicates the ``ECN_NotECT`` codepoint.
Index: src/internet/doc/ipv6.rst
===================================================================
--- a/src/internet/doc/ipv6.rst
+++ b/src/internet/doc/ipv6.rst
@@ -224,6 +224,30 @@
 This might be changed in the future, so as to avoid issues with real-world 
 integrated simulations.
 
+Explicit Congestion Notification (ECN) bits in IPv6
+===================================================
+
+- In IPv6, ECN bits are the last 2 bits of the Traffic class and occupy 10th and 11th bit 
+  in the header.
+
+- The IPv6 header class defines an EcnType enum with all four ECN codepoints
+  (ECN_NotECT, ECN_ECT1, ECN_ECT0, ECN_CE) mentioned
+  in RFC 3168, and also a setter and getter method to handle ECN values in
+  the Traffic Class field.
+
+Ipv6QueueDiscItem
+*****************
+
+The traffic control sublayer in |ns3| handles objects of class
+``QueueDiscItem`` which are used to hold an ns3::Packet and a ns3::Header.
+This is done to facilitate the marking of packets for Explicit
+Congestion Notification.  The ``Mark ()`` method is implemented in
+Ipv6QueueDiscItem. It is a boolean method and returns true if marking
+the packet is successful; i.e., it successfully sets the CE bit in
+IPv4 header.  ``Mark ()`` will return false, however, if the IPv6
+header indicates the ``ECN_NotECT`` codepoint.
+
+
 Host and Router behaviour in IPv6 and |ns3|
 ===========================================
 
Index: src/internet/model/ipv4-queue-disc-item.cc
===================================================================
--- a/src/internet/model/ipv4-queue-disc-item.cc
+++ b/src/internet/model/ipv4-queue-disc-item.cc
@@ -80,6 +80,19 @@
 }
 
 bool
+Ipv4QueueDiscItem::Mark (void)
+{
+  NS_LOG_FUNCTION (this);
+  if (!m_headerAdded && (m_header.GetEcn () == Ipv4Header::ECN_ECT1 || m_header.GetEcn () == Ipv4Header::ECN_ECT0))
+    {
+      m_header.SetEcn (Ipv4Header::ECN_CE);
+      return true;
+    }
+  return false;
+}
+
+
+bool
 Ipv4QueueDiscItem::GetUint8Value (QueueItem::Uint8Values field, uint8_t& value) const
 {
   bool ret = false;
Index: src/internet/model/ipv4-queue-disc-item.h
===================================================================
--- a/src/internet/model/ipv4-queue-disc-item.h
+++ b/src/internet/model/ipv4-queue-disc-item.h
@@ -79,6 +79,12 @@
    */
   virtual bool GetUint8Value (Uint8Values field, uint8_t &value) const;
 
+  /**
+   * \brief Marks the packet by setting ECN_CE bits if the packet has ECN_ECT0 or ECN_ECT1 bits set
+   * \return true if the packet gets marked, false otherwise
+   */
+  virtual bool Mark (void);
+
 private:
   /**
    * \brief Default constructor
Index: src/internet/model/ipv6-header.cc
===================================================================
old mode 100644
new mode 100755
--- a/src/internet/model/ipv6-header.cc
+++ b/src/internet/model/ipv6-header.cc
@@ -192,6 +192,13 @@
   m_trafficClass |= (dscp << 2);
 }
 
+void Ipv6Header::SetEcn (EcnType ecn)
+{
+  NS_LOG_FUNCTION (this << ecn);
+  m_trafficClass &= 0xFC; // Clear out the ECN part, retain 6 bits of DSCP
+  m_trafficClass |= ecn;
+}
+
 Ipv6Header::DscpType Ipv6Header::GetDscp (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -251,6 +258,31 @@
     };
 }
 
+Ipv6Header::EcnType
+Ipv6Header::GetEcn (void) const
+{
+  NS_LOG_FUNCTION (this);
+  // Extract only last 2 bits of Traffic Class byte, i.e 0x3
+  return EcnType (m_trafficClass & 0x3);
+}
+
+std::string Ipv6Header::EcnTypeToString (EcnType ecn) const
+{
+  NS_LOG_FUNCTION (this << ecn);
+  switch (ecn)
+    {
+      case ECN_NotECT:
+        return "Not-ECT";
+      case ECN_ECT1:
+        return "ECT (1)";
+      case ECN_ECT0:
+        return "ECT (0)";
+      case ECN_CE:
+        return "CE";
+      default:
+        return "Unknown ECN codepoint";
+    };
+}
 
 } /* namespace ns3 */
 
Index: src/internet/model/ipv6-header.h
===================================================================
old mode 100644
new mode 100755
--- a/src/internet/model/ipv6-header.h
+++ b/src/internet/model/ipv6-header.h
@@ -144,6 +144,32 @@
    */
   std::string DscpTypeToString (DscpType dscp) const;
 
+  enum EcnType
+   {
+     // Prefixed with "ECN" to avoid name clash
+     ECN_NotECT = 0x00,
+     ECN_ECT1 = 0x01,
+     ECN_ECT0 = 0x02,
+     ECN_CE = 0x03
+   };
+
+  /**
+   * \brief Set ECN Field
+   * \param ecn ECN Type
+   */
+  void SetEcn (EcnType ecn);
+
+  /**
+   * \return the ECN field of this packet.
+   */
+  EcnType GetEcn (void) const;
+
+  /**
+   * \param ecn the ECNType
+   * \return std::string of ECNType
+   */
+  std::string EcnTypeToString (EcnType ecn) const;
+
   /**
    * \brief Set the "Flow label" field.
    * \param flow the 20-bit value
Index: src/internet/model/ipv6-queue-disc-item.cc
===================================================================
--- a/src/internet/model/ipv6-queue-disc-item.cc
+++ b/src/internet/model/ipv6-queue-disc-item.cc
@@ -80,6 +80,18 @@
 }
 
 bool
+Ipv6QueueDiscItem::Mark (void)
+{
+  NS_LOG_FUNCTION (this);
+  if (!m_headerAdded && (m_header.GetEcn () == Ipv6Header::ECN_ECT1 || m_header.GetEcn () == Ipv6Header::ECN_ECT0))
+    {
+      m_header.SetEcn (Ipv6Header::ECN_CE);
+      return true;
+    }
+  return false;
+}
+
+bool
 Ipv6QueueDiscItem::GetUint8Value (QueueItem::Uint8Values field, uint8_t& value) const
 {
   bool ret = false;
Index: src/internet/model/ipv6-queue-disc-item.h
===================================================================
--- a/src/internet/model/ipv6-queue-disc-item.h
+++ b/src/internet/model/ipv6-queue-disc-item.h
@@ -79,6 +79,12 @@
    */
   virtual bool GetUint8Value (Uint8Values field, uint8_t &value) const;
 
+  /**
+   * \brief Marks the packet by setting ECN_CE bits if the packet has ECN_ECT0 or ECN_ECT1 bits set
+   * \return true if the packet gets marked, false otherwise
+   */
+  virtual bool Mark (void);
+
 private:
   /**
    * \brief Default constructor
Index: src/test/ns3tc/pie-queue-disc-test-suite.cc
===================================================================
--- a/src/test/ns3tc/pie-queue-disc-test-suite.cc
+++ b/src/test/ns3tc/pie-queue-disc-test-suite.cc
@@ -36,6 +36,7 @@
   PieQueueDiscTestItem (Ptr<Packet> p, const Address & addr, uint16_t protocol);
   virtual ~PieQueueDiscTestItem ();
   virtual void AddHeader (void);
+  virtual bool Mark(void);
 
 private:
   PieQueueDiscTestItem ();
@@ -57,6 +58,12 @@
 {
 }
 
+bool
+PieQueueDiscTestItem::Mark (void)
+{
+  return false;
+}
+
 class PieQueueDiscTestCase : public TestCase
 {
 public:
Index: src/traffic-control/doc/queue-discs.rst
===================================================================
--- a/src/traffic-control/doc/queue-discs.rst
+++ b/src/traffic-control/doc/queue-discs.rst
@@ -87,12 +87,16 @@
 packet, a new class, QueueDiscItem, is derived from QueueItem to store such
 additional information for each packet. Thus, internal queues are implemented as
 Queue objects storing QueueDiscItem objects. Also, there could be the need to store
-further information depending on the network layer protocol of the packet. For
+further information depending on the network layer protocol of the packet. 
+
+For
 instance, for IPv4 and IPv6 packets it is needed to separately store the header
-and the payload, so that header fields can be manipulated, e.g., to support ECN.
-To this end, Ipv4QueueDiscItem and Ipv6QueueDiscItem are derived from QueueDiscItem
-to additionally store the packet header and provide protocol specific operations
-such as ECN marking.
+and the payload, so that header fields can be manipulated, e.g., to support 
+Explicit Congestion Notification as defined in RFC 3168.  To this end, 
+subclasses ``Ipv4QueueDiscItem`` and ``Ipv6QueueDiscItem`` are derived from 
+``QueueDiscItem``
+to additionally store the IP header and provide protocol specific operations
+such as ECN marking. 
 
 Classes are implemented via the QueueDiscClass class, which just consists of a pointer
 to the attached queue disc. Such a pointer is accessible through the QueueDisc attribute.
Index: src/traffic-control/doc/red.rst
===================================================================
old mode 100644
new mode 100755
--- a/src/traffic-control/doc/red.rst
+++ b/src/traffic-control/doc/red.rst
@@ -34,7 +34,30 @@
 in ns-3 contains implementation of both the features, and is a port of Sally
 Floyd's ns-2 ARED model. Note that the user is allowed to choose and explicitly
 configure the simulation by selecting feature (i) or feature (ii), or both.
- 
+
+Explicit Congestion Notification (ECN)
+======================================
+This RED model supports an ECN mode of operation to notify endpoints of
+congestion that may be developing in a bottleneck queue, without resorting
+to packet drops. As recommended in RFC 3168, ECN marking is used only when
+an incoming packet has an ECT bit set in its IP header, and if the
+average queue length is between the minimum and maximum threshold. Packets
+are always dropped when the average queue length is above the maximum
+threshold, or if the ECT codepoint is not set in the IP header.
+
+In order to test the functionality of ECN support in RED, a test suite
+named ``ecn-red-queue-disc-test-suite.cc`` has been developed.  It depends on
+the internet model and hence, is placed in ``src/test/ns3tc``. Furthermore,
+a test suite named ``ecn-ipv6-red-queue-disc-test-suite.cc`` is also
+provided in ``src/test/ns3tc`` to verify the working of ECN in RED
+QueueDisc with IPv6.
+
+The implementation of support for ECN marking is done in such a way as
+to not impose an internet module dependency on the traffic control module.
+The RED model does not directly set ECN bits on the header, but delegates
+that job to the QueueDiscItem class.  As a result, it is possible to
+use RED queues for other non-IP QueueDiscItems that may or may not support
+the ``Mark ()`` method.
 
 References
 ==========
@@ -45,6 +68,9 @@
 ARED queue implementation is based on the algorithm provided in:
 S. Floyd et al, http://www.icir.org/floyd/papers/adaptiveRed.pdf
 
+The addition of explicit congestion notification (ECN) to IP:
+K. K. Ramakrishnan et al, https://tools.ietf.org/html/rfc3168
+
 Attributes
 ==========
 
Index: src/traffic-control/model/queue-disc.h
===================================================================
--- a/src/traffic-control/model/queue-disc.h
+++ b/src/traffic-control/model/queue-disc.h
@@ -91,6 +91,13 @@
    */
   virtual void Print (std::ostream &os) const;
 
+  /**
+   * \brief Marks the packet as a substitute for dropping it, such as for Explicit Congestion Notification
+   *
+   * \return true if the packet gets marked, false otherwise
+   */
+  virtual bool Mark (void) = 0;
+
 private:
   /**
    * \brief Default constructor
Index: src/traffic-control/model/red-queue-disc.cc
===================================================================
old mode 100644
new mode 100755
--- a/src/traffic-control/model/red-queue-disc.cc
+++ b/src/traffic-control/model/red-queue-disc.cc
@@ -193,6 +193,11 @@
                    TimeValue (MilliSeconds (20)),
                    MakeTimeAccessor (&RedQueueDisc::m_linkDelay),
                    MakeTimeChecker ())
+    .AddAttribute ("UseEcn",
+                   "Checks if queue-disc is ECN Capable",
+                   BooleanValue (false),
+                   MakeBooleanAccessor (&RedQueueDisc::m_useEcn),
+                   MakeBooleanChecker ())
   ;
 
   return tid;
@@ -392,10 +397,18 @@
 
   if (dropType == DTYPE_UNFORCED)
     {
-      NS_LOG_DEBUG ("\t Dropping due to Prob Mark " << m_qAvg);
-      m_stats.unforcedDrop++;
-      Drop (item);
-      return false;
+      if (m_useEcn && item->Mark ())
+        {
+          NS_LOG_DEBUG ("\t Marking due to Prob Mark " << m_qAvg);
+          m_stats.unforcedMark++;
+        }
+      else
+        {
+          NS_LOG_DEBUG ("\t Dropping due to Prob Mark " << m_qAvg);
+          m_stats.unforcedDrop++;
+          Drop (item);
+          return false;
+        }
     }
   else if (dropType == DTYPE_FORCED)
     {
@@ -412,13 +425,18 @@
 
   bool retval = GetInternalQueue (0)->Enqueue (item);
 
+  if (!retval)
+    {
+      m_stats.qLimDrop++;
+    }
+
   // If Queue::Enqueue fails, QueueDisc::Drop is called by the internal queue
   // because QueueDisc::AddInternalQueue sets the drop callback
 
   NS_LOG_LOGIC ("Number packets " << GetInternalQueue (0)->GetNPackets ());
   NS_LOG_LOGIC ("Number bytes " << GetInternalQueue (0)->GetNBytes ());
 
-  return retval;
+  return retval; 
 }
 
 /*
@@ -471,6 +489,7 @@
   m_stats.forcedDrop = 0;
   m_stats.unforcedDrop = 0;
   m_stats.qLimDrop = 0;
+  m_stats.unforcedMark = 0;
 
   m_qAvg = 0.0;
   m_count = 0;
Index: src/traffic-control/model/red-queue-disc.h
===================================================================
old mode 100644
new mode 100755
--- a/src/traffic-control/model/red-queue-disc.h
+++ b/src/traffic-control/model/red-queue-disc.h
@@ -108,9 +108,10 @@
     uint32_t unforcedDrop;  //!< Early probability drops
     uint32_t forcedDrop;    //!< Forced drops, qavg > max threshold
     uint32_t qLimDrop;      //!< Drops due to queue limits
+    uint32_t unforcedMark;  //!< Early probability marks
   } Stats;
 
-  /** 
+  /**
    * \brief Drop types
    */
   enum
@@ -298,6 +299,7 @@
   bool m_isNs1Compat;       //!< Ns-1 compatibility
   DataRate m_linkBandwidth; //!< Link bandwidth
   Time m_linkDelay;         //!< Link delay
+  bool m_useEcn;            //!< True for enabling red-queue-disc to use ECN
 
   // ** Variables maintained by RED
   double m_vProb1;          //!< Prob. of packet drop before "count"
Index: src/traffic-control/test/codel-queue-disc-test-suite.cc
===================================================================
--- a/src/traffic-control/test/codel-queue-disc-test-suite.cc
+++ b/src/traffic-control/test/codel-queue-disc-test-suite.cc
@@ -59,6 +59,7 @@
   CodelQueueDiscTestItem (Ptr<Packet> p, const Address & addr, uint16_t protocol);
   virtual ~CodelQueueDiscTestItem ();
   virtual void AddHeader (void);
+  virtual bool Mark(void);
 
 private:
   CodelQueueDiscTestItem ();
@@ -80,6 +81,12 @@
 {
 }
 
+bool
+CodelQueueDiscTestItem::Mark (void)
+{
+  return false;
+}
+
 // Test 1: simple enqueue/dequeue with no drops
 class CoDelQueueDiscBasicEnqueueDequeue : public TestCase
 {
Index: src/traffic-control/test/red-queue-disc-test-suite.cc
===================================================================
--- a/src/traffic-control/test/red-queue-disc-test-suite.cc
+++ b/src/traffic-control/test/red-queue-disc-test-suite.cc
@@ -30,12 +30,15 @@
 #include "ns3/simulator.h"
 
 using namespace ns3;
+bool ecnCapablePackets = false;
+bool ecnEnabled = false;
 
 class RedQueueDiscTestItem : public QueueDiscItem {
 public:
   RedQueueDiscTestItem (Ptr<Packet> p, const Address & addr, uint16_t protocol);
   virtual ~RedQueueDiscTestItem ();
   virtual void AddHeader (void);
+  virtual bool Mark(void);
 
 private:
   RedQueueDiscTestItem ();
@@ -57,6 +60,16 @@
 {
 }
 
+bool
+RedQueueDiscTestItem::Mark (void)
+{
+  if (ecnCapablePackets)
+    {
+      return true;
+    }
+  return false;
+}
+
 class RedQueueDiscTestCase : public TestCase
 {
 public:
@@ -64,6 +77,7 @@
   virtual void DoRun (void);
 private:
   void Enqueue (Ptr<RedQueueDisc> queue, uint32_t size, uint32_t nPkt);
+  void EnqueueEcnCapable (Ptr<RedQueueDisc> queue, uint32_t size, uint32_t nPkt);
   void RunRedTest (StringValue mode);
 };
 
@@ -287,12 +301,97 @@
   st = StaticCast<RedQueueDisc> (queue)->GetStats ();
   drop.test7 = st.unforcedDrop + st.forcedDrop + st.qLimDrop;
   NS_TEST_EXPECT_MSG_GT (drop.test7, drop.test3, "Test 7 should have more drops than test 3");
+
+  
+  // test 8: RED queue disc is ECN enabled, but packets are not ECN capable 
+  queue = CreateObject<RedQueueDisc> ();
+  minTh = 30 * modeSize;
+  maxTh = 90 * modeSize;
+  ecnEnabled = true;
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("Mode", mode), true,
+                         "Verify that we can actually set the attribute Mode");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("MinTh", DoubleValue (minTh)), true,
+                         "Verify that we can actually set the attribute MinTh");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("MaxTh", DoubleValue (maxTh)), true,
+                         "Verify that we can actually set the attribute MaxTh");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("QueueLimit", UintegerValue (qSize)), true,
+                         "Verify that we can actually set the attribute QueueLimit");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("QW", DoubleValue (0.002)), true,
+                         "Verify that we can actually set the attribute QW");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("LInterm", DoubleValue (2)), true,
+                         "Verify that we can actually set the attribute LInterm");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("Gentle", BooleanValue (true)), true,
+                         "Verify that we can actually set the attribute Gentle");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("UseEcn", BooleanValue (true)), true,
+                         "Verify that we can actually set the attribute UseECN");
+  queue->Initialize ();
+  Enqueue (queue, pktSize, 300); 
+  ecnCapablePackets = false;
+  st = StaticCast<RedQueueDisc> (queue)->GetStats ();
+  // Packets are not ECN capable, so there should be only unforced drops, no unforced marks
+  NS_TEST_EXPECT_MSG_NE (st.unforcedDrop, 0, "There should be some unforced drops");
+  NS_TEST_EXPECT_MSG_EQ (st.unforcedMark, 0, "There should be no unforced marks");
+
+  
+  // test 9: Packets are ECN capable, but RED queue disc is not ECN enabled
+  queue = CreateObject<RedQueueDisc> ();
+  ecnEnabled = false;
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("Mode", mode), true,
+                         "Verify that we can actually set the attribute Mode");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("MinTh", DoubleValue (minTh)), true,
+                         "Verify that we can actually set the attribute MinTh");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("MaxTh", DoubleValue (maxTh)), true,
+                         "Verify that we can actually set the attribute MaxTh");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("QueueLimit", UintegerValue (qSize)), true,
+                         "Verify that we can actually set the attribute QueueLimit");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("QW", DoubleValue (0.002)), true,
+                         "Verify that we can actually set the attribute QW");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("LInterm", DoubleValue (2)), true,
+                         "Verify that we can actually set the attribute LInterm");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("Gentle", BooleanValue (true)), true,
+                         "Verify that we can actually set the attribute Gentle");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("UseEcn", BooleanValue (false)), true,
+                         "Verify that we can actually set the attribute UseECN");
+  queue->Initialize ();
+  EnqueueEcnCapable (queue, pktSize, 300);
+  st = StaticCast<RedQueueDisc> (queue)->GetStats ();
+  // RED queue disc is not ECN enabled, so there should be only unforced drops, no unforced marks
+  NS_TEST_EXPECT_MSG_NE (st.unforcedDrop, 0, "There should be some unforced drops");
+  NS_TEST_EXPECT_MSG_EQ (st.unforcedMark, 0, "There should be no unforced marks");
+
+  
+  // test 10: Packets are ECN capable and RED queue disc is ECN enabled
+  queue = CreateObject<RedQueueDisc> ();
+  ecnEnabled = true;
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("Mode", mode), true,
+                         "Verify that we can actually set the attribute Mode");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("MinTh", DoubleValue (minTh)), true,
+                         "Verify that we can actually set the attribute MinTh");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("MaxTh", DoubleValue (maxTh)), true,
+                         "Verify that we can actually set the attribute MaxTh");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("QueueLimit", UintegerValue (qSize)), true,
+                         "Verify that we can actually set the attribute QueueLimit");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("QW", DoubleValue (0.002)), true,
+                         "Verify that we can actually set the attribute QW");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("LInterm", DoubleValue (2)), true,
+                         "Verify that we can actually set the attribute LInterm");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("Gentle", BooleanValue (true)), true,
+                         "Verify that we can actually set the attribute Gentle");
+  NS_TEST_EXPECT_MSG_EQ (queue->SetAttributeFailSafe ("UseEcn", BooleanValue (true)), true,
+                         "Verify that we can actually set the attribute UseECN");
+  queue->Initialize ();
+  EnqueueEcnCapable (queue, pktSize, 300);
+  st = StaticCast<RedQueueDisc> (queue)->GetStats ();
+  // Packets are ECN capable, RED queue disc is ECN enabled; there should be only unforced marks, no unforced drops
+  NS_TEST_EXPECT_MSG_EQ (st.unforcedDrop, 0, "There should be no unforced drops");
+  NS_TEST_EXPECT_MSG_NE (st.unforcedMark, 0, "There should be some unforced marks");
 }
 
 void 
 RedQueueDiscTestCase::Enqueue (Ptr<RedQueueDisc> queue, uint32_t size, uint32_t nPkt)
 {
   Address dest;
+  ecnCapablePackets = false;
   for (uint32_t i = 0; i < nPkt; i++)
     {
       queue->Enqueue (Create<RedQueueDiscTestItem> (Create<Packet> (size), dest, 0));
@@ -300,6 +399,17 @@
 }
 
 void
+RedQueueDiscTestCase::EnqueueEcnCapable (Ptr<RedQueueDisc> queue, uint32_t size, uint32_t nPkt)
+{
+  Address dest;
+  ecnCapablePackets = true;
+  for (uint32_t i = 0; i < nPkt; i++)
+    {
+      queue->Enqueue (Create<RedQueueDiscTestItem> (Create<Packet> (size), dest, 0));
+    }
+} 
+
+void
 RedQueueDiscTestCase::DoRun (void)
 {
   RunRedTest (StringValue ("QUEUE_MODE_PACKETS"));
